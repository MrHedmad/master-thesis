---
title: "Report - GBM Pancancer Analysis"
output:
  pdf_document: default
  html_notebook:
    code_folding: none
  html_document:
    df_print: paged
---

```{r global options, include = FALSE}
knitr::opts_chunk$set(warning=FALSE)
```

# Preamble

```{r}
library(plyr) # Data shape casting (needs to be loaded before dplyr)
library(tidyverse)
# Tidyverse loads ggplot2, purrr, tibble, dplyr, tidyr, stringr, readr and forcats
options(dplyr.summarise.inform = FALSE) # This suppresses the warning that summarise makes about grouping.
library(reshape2) # Data melt and cast
library(glmulti) # Multimodel inference
library(cowplot) # Margin plots made (a bit) easier
library(ggfortify) # `autoplot` for glms
library(MASS) # glm.nb implementation
library(clusterSim) # Index.DB and other measures

# The docstring package is entirely optional but it allows me to print out help messages
# as I write more code, so it's nice as I forget what my own functions do often...
library(docstring)
```

Other packages that need to be installed (I call them sporadically without bringing them into scope):
```{r, eval=FALSE}
library(ggrepel)
library(jtools) # Provides easy effect plots
```

Load the preprocessed data. The data is the one that comes from the `data_preprocessing.R` script. It's

```{r}
load(file = "F:/Data/University/Thesis/Data/CHASMplus/preprocessed_CHASM_data.RData")
# I just take out the tumor names for easy iteration later
p.names <- names(projects)

get.name <- function(clinical) {
  #' Helper function to get the name of a clinical dataframe
  return(attr(clinical, "project.id"))
}

# I save the tumor type in the clinical data as an attribute, as basically every function
# that takes the clinical data also needs it (like, for plotting)
# This way, I don't need to pass it manually every time, but just extract it from the data
# itself.
for (name in p.names) {
  attr(projects[[name]]$clinical, "project.id") <- name
}
```

# Descriptive Analysis

> What is the shape of the data?

## Basic Summary Statistics

Basic statistics (`summary` is a bit messy as it considers all variables):

```{r}
# Sometimes, there are no males, so the function would error, so we need a "safe" extract
extract_safe <- function(t, what, default = 0) {
  #' Safely extract variables
  #'
  #' Extract from a dataframe T a variable WHAT. If it's missing, return DEFAULT instead
  tryCatch(t[[what]], error = function(e) default)
}

sum_clin <- function(clinical.data){
  # Get a custom summary for the clinical data
  #
  # Get some statistics about clinical data. Includes overall numerosity, driver numerosity,
  # means and standard deviations for passenger/driver distributions, and more.
  name <- get.name(clinical.data)
  data <- clinical.data
  totn <- length(data$ID)
  n0mut <- length(data$ID[data$driver.freq == 0])
  perc0mut <- n0mut/totn*100
  sex <- table(data$gender)/totn*100

  obj <- data.frame(
    # tumor metadata
    ID = name,
    # Numerosities
    numerosity = totn,
    numerosity.0.drivers = n0mut,
    percent.0.drivers = n0mut/totn*100,
    # Driver distributions
    mean.driver.nr = mean(data$driver.freq),
    median.driver.nr = median(data$driver.freq),
    sd.driver.nr = sd(data$driver.freq),
    driver.var.coff = sd(data$driver.freq) / mean(data$driver.freq),
    # Passenger distributions
    mean.passenger.nr = mean(data$passenger.freq),
    median.passenger.nr = median(data$passenger.freq),
    sd.passenger.nr = sd(data$passenger.freq),
    passenger.var.coff = sd(data$passenger.freq) / mean(data$passenger.freq),
    # Sex
    percent.reported.male = signif(extract_safe(sex, "male"), digits=4),
    # Age
    mean.age.years = mean((-data$days_to_birth)/365.25, na.rm = TRUE),
    sd.age.years = sd((-data$days_to_birth)/365.25, na.rm = TRUE)
  )

  class(obj) <- "clinical_summary"

  return(obj)
}

print.clinical_summary <- function(clin.stats){
  # Pretty print the clinical data summary
  #
  # Takes the clinical data, and well, prints it but better.
  l <- function(x){return(signif(x, digits = 4))}
  cat(paste(
    "Statistics for clinical data - ", clin.stats$ID, "\n", "\n",
    "Numerosities:\n",
    "\tNumber of patients :          ", clin.stats$numerosity, "\n",
    "\tNr. of pat. with no drivers : ", clin.stats$numerosity.0.drivers, "\n",
    "\t% of pat. with no drivers :   ", l(clin.stats$percent.0.drivers), " %\n",
    "Driver Distribution:\n",
    "\tMean Driver frequency :       ", l(clin.stats$mean.driver.nr), "\n",
    "\tStandard Deviation of Mean :  ", l(clin.stats$sd.driver.nr), "\n",
    "\tVariation Coefficient:        ", l(clin.stats$driver.var.coff), "\n",
    "Passenger Distribution:\n",
    "\tMean passenger frequency :    ", l(clin.stats$mean.passenger.nr), "\n",
    "\tStandard Deviation of Mean :  ", l(clin.stats$sd.passenger.nr), "\n",
    "\tVariation Coefficient:        ", l(clin.stats$passenger.var.coff), "\n",
    "\tMedian passenger frequency:   ", l(clin.stats$median.passenger.nr), "\n",
    "\n",
    "% reported male:  ", clin.stats$percent.reported.male, " %\n",
    "Mean Age (years): ", l(clin.stats$mean.age.years), "\n",
    "SD age (years):   ", l(clin.stats$sd.age.years),
    sep=""
  ))
}

descriptive.stats <- list()
for (name in p.names) {
  descriptive.stats[[name]] <- sum_clin(projects[[name]]$clinical)
}
fused.stats <- descriptive.stats %>% reduce(rbind)
fused.stats
# Print out only GBM long stats
print(descriptive.stats$`TCGA-GBM`)
```

We can now see some distributions.

## Frequency Histograms

```{r, fig.width=6, fig.height=4}
freq.histogram <- function(clinical.data, variable, colour = "darkblue", label.colour = colour){
  #' Mutation histograms from clinical frames
  #'
  #' Produce a histogram with the distribution of the mutational frequencies.
  #' @param clinical.data Clinical data from a project
  #' @param variable The variable to plot. Either `"driver.freq"` or `"passenger.freq"`
  #' @param project.name The name of the project
  #'
  #' Made to work with project-like clinical data with a `project.id` attribute.
  library(ggplot2)

  stopifnot(variable %in% c("driver.freq", "passenger.freq"))

  data <- clinical.data
  title <- paste("Number of driver mutations per patient -", get.name(data))

  tabulated_freqs <- table(data[[variable]])

  p <- ggplot(data, aes(x=.data[[variable]])) +
    theme_minimal() +
    geom_bar(stat="count", show.legend=FALSE, fill=colour, width=1) +
    scale_x_continuous(breaks=seq(from=0, to=max(data[[variable]]), by=1), minor_breaks = NULL) +
    xlab("Number of Driver Mutations") + ylab("Number of Patients") +
    ggtitle(title)

  # I need to change dynamically the colours of the labels.
  pdata <- ggplot_build(p)
  set_vjust_val <- function(x, t=10){if(x > t){return(2)} else {return(-2)}}
  set_vjust_col <- function(x, t=10){if(x > t){return("white")} else {return(label.colour)}}
  unnested <- pdata[[1]][[1]]
  vjust_values <- unlist(lapply(unnested$count, set_vjust_val, t=max(unnested$count)/10))
  vjust_colours <- unlist(lapply(unnested$count, set_vjust_col, t=max(unnested$count)/10))

  p <- p + geom_text(stat='count', aes(label=..count..), vjust=vjust_values, col=vjust_colours)
  print(p)
}

for (name in p.names) {
  freq.histogram(projects[[name]]$clinical, variable = "driver.freq")
}
```

I don't even bother printing out the passenger distributions, as they are barely legible without cropping the data.

## Passenger - Driver distributions

Now, boxplots of the distributions of passengers by the amount of drivers.

```{r, fig.width=6, fig.height=4}
driver.boxplot <- function(clinical.data, colour = "lightblue"){
  #' Create a driver boxplot graph from project clinical data
  #'
  #' The scales of the passenger frequency is logarithmic (base 10), because the data has a very
  #' long tail towards large numbers.
  #' @param clinical.data Clinical data from a project
  #' @param colour The colour that fills the boxplots
  #'
  #' Made to work with project-like clinical data with a `project.id` attribute.
  clinical.data$driver.freq <- as.factor(clinical.data$driver.freq)
  project.id <- get.name(clinical.data)

  base.plot <- ggplot(clinical.data, aes(group = driver.freq, x = driver.freq, y = passenger.freq)) +
    stat_boxplot(geom ='errorbar', width = 0.4) +
    geom_point(alpha=0) +
    geom_boxplot(fill = colour) +
    scale_y_log10() +
    ylab("Passenger frequency") + xlab("Driver Frequency") +
    ggtitle(paste("Pass/Driver distributions -", project.id)) +
    theme_bw() + theme(panel.grid.minor = element_blank()) +
    annotation_logticks(sides = "l")

  clinical.data$driver.freq <- as.numeric(clinical.data$driver.freq)
  x.box <- axis_canvas(base.plot, axis = "x", coord_flip = TRUE) +
    stat_boxplot(data = clinical.data, aes(y = driver.freq, x = 1), geom ='errorbar') +
    geom_boxplot(data = clinical.data, aes(y = driver.freq, x = 1), fill = colour) +
    coord_flip()
  # Re-adding the log10 scale generates a warning, but it's useless. So I suppress it.
  suppressMessages(
    y.box <- axis_canvas(base.plot, axis = "y") +
      scale_y_log10() +
      stat_boxplot(data = clinical.data, aes(y = passenger.freq, x = 1), geom ='errorbar') +
      geom_boxplot(data = clinical.data, aes(y = passenger.freq, x = 1), fill = colour)
  )

  empty <- ggdraw()

  final.plot <- insert_xaxis_grob(base.plot, x.box, grid::unit(7, "mm"), position = "top")
  final.plot <- insert_xaxis_grob(final.plot, empty, grid::unit(2, "mm"), position = "top")

  final.plot <- insert_yaxis_grob(final.plot, y.box, grid::unit(7, "mm"), position = "right")
  final.plot <- insert_yaxis_grob(final.plot, empty, grid::unit(2, "mm"), position = "right")

  return(ggdraw(final.plot))
}

for (name in p.names) {
  print(driver.boxplot(projects[[name]]$clinical, colour = "lightgreen"))
}
```
The plots complain that there are some infinite values in the axes. Maybe there are 0 passenger datapoints? There are very few rows affected, however, so it shouldn't be a problem.

Some tumors have only patients with low mutational burden, while others have high mutational burden. I plot the average amount of drivers vs the average amount of passenger for each tumor type.

```{r, fig.width=10}
crop.at <- function(clinical.data, percentile) {
  # Crops clinical data of a project at some percentile for passenger mutations
  return(subset(clinical.data, clinical.data$passenger.freq < quantile(clinical.data$passenger.freq, percentile / 100)))
}


averages <- lapply(projects, function(x) {
  name <- get.name(x$clinical)
  x$clinical %>% crop.at(90) -> x$clinical
  return(
    data.frame(
      ID = name,
      avg.drivers = mean(x$clinical$driver.freq),
      avg.passengers = mean(x$clinical$passenger.freq)
    )
  )
})
averages %>% reduce(rbind) -> averages

ggplot(averages, aes(x = avg.drivers, y = avg.passengers)) +
  geom_smooth(method = "lm", formula = "y ~ x", se=FALSE, alpha = 0.5, colour = "lightblue") +
  geom_point(color = "red", size = 2) +
  ggrepel::geom_text_repel(aes(label = ID), size = 3, max.overlaps = 15, min.segment.length = 0) +
  #scale_x_continuous(trans=scales::pseudo_log_trans(base = 10, sigma = 0.1)) +
  #scale_y_continuous(trans=scales::pseudo_log_trans(base = 10)) +
  scale_x_log10() +
  scale_y_log10() +
  annotation_logticks() +
  ggtitle("Average Passenge vs Average Drivers") +
  xlab("Average Drivers") + ylab("Average Passengers") +
  theme_bw()

```

The above log/log plot shows that there is some link between the average amount of drivers and the average amount of passengers in a tumor type. It could be worth modelling. Interestingly, Glioblastoma Multiforme seems to be in the middle of the distribution. The faint blue line represents a linear model with formula `y ~ x`.

# Novel mutations

> Are there any novel mutations detected by the CHASMplus?

I'll use the Cancer Gene Census list of genes as the list of known genes. I downloaded it on the 15th of March, 2021. I pre-filtered it manually to only contain the unique genes, and saved it as such.

I include the code that generated the loaded file for posterity:

```{r, eval=FALSE}
cgc.all <- read.table(file = "F:/Data/University/Thesis/Data/CosmicMutantExportCensus.tsv", sep = "\t", header = TRUE)
known.gene.list <- unique(cgc.all$Gene.name)
write(known.gene.list, "F:/Data/University/Thesis/Data/UniqueCosmicMutations.txt")
rm(cgc.all)
```

```{r}
known.gene.list <- readLines("F:/Data/University/Thesis/Data/UniqueCosmicMutations.txt")
```

The HUGO renames (GENE_MUTATION) are not here, at least in the same format I have...
TODO: convert between the two.

```{r}
novel.genes <- list()
for (name in p.names) {
  projects[[name]]$crystal$Hugo %>% subset(!projects[[name]]$crystal$Hugo %in% known.gene.list) %>% unique() -> novel.genes[[name]]
}
```

Fuse all of them into a single, "new genes" list.

```{r}
novel.genes %>% reduce(c) %>% unique() -> all.novel.genes
all.novel.genes %>% write("F:/Data/University/Thesis/Data/NovelMutations.txt")
print(all.novel.genes)
```

There are 435 novel genes across all tumor types. I'll run them through `EnricR` to see if there are some enrichments.

# Models

## Model Data preprocessing

The data is still a bit raw to be fed directly into models. There are a lot of passenger outliers, so I crop the distributions at the 90th percentile. This is arbitrary, but get rid of a lot of outlier patients.

### High Passenger Frequency distortion

First I need to crop the data at the 90th percentile for passenger mutations, or the models will be heavily distorted:

```{r}
# I make a second pointer here to keep the projects untouched by the model preprocessing.
model.data <- projects

for (name in p.names) {
  # This is a tad dangerous, as shouldn't be run twice.
  model.data[[name]]$clinical %>% crop.at(90) -> model.data[[name]]$clinical
}
```

### Variable level simplification

Now I need to remove some types of levels from the data, otherwise there are too many of them. I also declare which variables are of interest. As far as I can tell, the clinical scores "overwrite" the pathologic ones if they are present.

```{r}
# Vector of variables that we think are of interest
# This were hand picked by the professor.
selected.vars <- c("gender", "vital_status", "age_at_diagnosis", "icd_10_code", "prior_malignancy", "alcohol_history", "bmi", "ajcc_clinical_m", "ajcc_clinical_n", "ajcc_clinical_t", "ajcc_clinical_stage", "ajcc_pathologic_m", "ajcc_pathologic_n", "ajcc_pathologic_t", "ajcc_pathologic_stage")
tumor.spec.vars <- c("ann_arbor_b_symptoms", "figo_stage", "masaoka_stage", "primary_gleason_grade", "secondary_gleason_grade")

all.vars <- c(selected.vars, tumor.spec.vars)

all.factors <- all.vars[!all.vars %in% c("age_at_diagnosis", "bmi")]

for (name in p.names) {
  collnamess <- names(model.data[[name]]$clinical)
  for (colname in collnamess) {
    if (colname %in% all.factors) {
      model.data[[name]]$clinical[[colname]] <- as.factor(model.data[[name]]$clinical[[colname]])
    }
    # Clinical ajcc scores considerations:
    # The scores are too precise to work well as model factors, so I simplify them here
    # into low-grade tumors and high grade tumors.
    if (colname == "ajcc_clinical_m") {
      model.data[[name]]$clinical[[colname]] <- revalue(model.data[[name]]$clinical[[colname]], c(
        "M0" = "M0",
        "M1" = "M1",
        "M1a" = "M1",
        "M1b" = "M1",
        "M1c" = "M1",
        "MX" = "MX",
        "cM0 (i+)" = "M0",
        "Unknown" = NA,
        "Not Reported" = NA),
        warn_missing = FALSE
      )
    }
    if (colname == "ajcc_clinical_n") {
      model.data[[name]]$clinical[[colname]] <- revalue(model.data[[name]]$clinical[[colname]], c(
        "N0" = "N0",
        "N0 (i+)" = "N0",
        "N0 (i-)" = "N0",
        "N0 (mol+)" = "N0",
        "N0 (mol-)" = "N0",
        "N1" = "N1",
        "N1a" = "N1",
        "N1b" = "N1",
        "N1bI" = "N1",
        "N1bII" = "N1",
        "N1bIII" = "N1",
        "N1bIV" = "N1",
        "N1c" = "N1",
        "N1mi" = "N1",
        "N2" = "N2+",
        "N2a" = "N2+",
        "N2b" = "N2+",
        "N2c" = "N2+",
        "N3" = "N2+",
        "N3a" = "N2+",
        "N3b" = "N2+",
        "N3c" = "N2+",
        "N4" = "N2+",
        "NX" = "NX",
        "Unknown" = NA,
        "Not Reported" = NA),
        warn_missing = FALSE
      )
    }
    if (colname == "ajcc_clinical_stage") {
      model.data[[name]]$clinical[[colname]] <- revalue(model.data[[name]]$clinical[[colname]], c(
        "Stage 0" = "Stage0",
        "Stage 0a" = "Stage0",
        "Stage 0is" = "Stage0",
        "Stage I" = "Stage1",
        "Stage IA" = "Stage1",
        "Stage IA1" = "Stage1",
        "Stage IA2" = "Stage1",
        "Stage IA3" = "Stage1",
        "Stage IB" = "Stage1",
        "Stage IB1" = "Stage1",
        "Stage IB2" = "Stage1",
        "Stage IC" = "Stage1",
        "Stage II" = "Stage2",
        "Stage IIA" = "Stage2",
        "Stage IIA1" = "Stage2",
        "Stage IIA2" = "Stage2",
        "Stage IIB" = "Stage2",
        "Stage IIC" = "Stage2",
        "Stage IIC1" = "Stage2",
        "Stage III" = "Stage3+",
        "Stage IIIA" = "Stage3+",
        "Stage IIIB" = "Stage3+",
        "Stage IIIC" = "Stage3+",
        "Stage IIIC1" = "Stage3+",
        "Stage IIIC2" = "Stage3+",
        "Stage IS" = "Stage1",
        "Stage IV" = "Stage1",
        "Stage IVA" = "Stage1",
        "Stage IVB" = "Stage1",
        "Stage IVC" = "Stage1",
        "Stage Tis" = "Stage0", # Small mutated cells - some do not consider this as cancer
        "Stage X" = "Stage X",
        "Unknown" = NA,
        "Not Reported" = NA),
        warn_missing = FALSE
      )
    }
    if (colname == "ajcc_clinical_t") {
      model.data[[name]]$clinical[[colname]] <- revalue(model.data[[name]]$clinical[[colname]], c(
        "T0" = "T0",
        "T1" = "T1",
        "T1a" = "T1",
        "T1a1" = "T1",
        "T1a2" = "T1",
        "T1b" = "T1",
        "T1b1" = "T1",
        "T1b2" = "T1",
        "T1c" = "T1",
        "T1mi" = "T1",
        "T2" = "T2",
        "T2a" = "T2",
        "T2a1" = "T2",
        "T2a2" = "T2",
        "T2b" = "T2",
        "T2c" = "T2",
        "T2d" = "T2",
        "T3" = "T3+",
        "T3a" = "T3+",
        "T3b" = "T3+",
        "T3c" = "T3+",
        "T3d" = "T3+",
        "T4" = "T3+",
        "T4a" = "T3+",
        "T4b" = "T3+",
        "T4c" = "T3+",
        "T4d" = "T3+",
        "T4e" = "T3+",
        "TX" = "TX",
        "Ta" = "T1",
        "Tis" = "T0",
        "Tis (DCIS)" = "T0",
        "Tis (LCIS)" = "T0",
        "Tis (Paget's)" = "T0",
        "Unknown" = NA,
        "Not Reported" = NA),
        warn_missing = FALSE
      )
    }
    if (colname == "ajcc_pathologic_m") {
      model.data[[name]]$clinical[[colname]] <- revalue(model.data[[name]]$clinical[[colname]], c(
        "M0" = "M0",
        "M1" = "M1",
        "M1a" = "M1",
        "M1b" = "M1",
        "M1c" = "M1",
        "M1d" = "M1",
        "M2" = "M2",
        "MX" = "MX",
        "cM0 (i+)" = "M0",
        "Unknown" = NA,
        "Not Reported" = NA),
        warn_missing = FALSE
      )
    }
    if (colname == "ajcc_pathologic_n") {
      model.data[[name]]$clinical[[colname]] <- revalue(model.data[[name]]$clinical[[colname]], c(
        "N0" = "N0",
        "N0 (i+)" = "N0",
        "N0 (i-)" = "N0",
        "N0 (mol+)" = "N0",
        "N0 (mol-)" = "N0",
        "N1" = "N1",
        "N1a" = "N1",
        "N1b" = "N1",
        "N1bI" = "N1",
        "N1bII" = "N1",
        "N1bIII" = "N1",
        "N1bIV" = "N1",
        "N1c" = "N1",
        "N1mi" = "N1",
        "N2" = "N2+",
        "N2a" = "N2+",
        "N2b" = "N2+",
        "N2c" = "N2+",
        "N3" = "N2+",
        "N3a" = "N2+",
        "N3b" = "N2+",
        "N3c" = "N2+",
        "N4" = "N2+",
        "NX" = "NX",
        "Unknown" = NA,
        "Not Reported" = NA),
        warn_missing = FALSE
      )
    }
    if (colname == "ajcc_pathologic_stage") {
      model.data[[name]]$clinical[[colname]] <- revalue(model.data[[name]]$clinical[[colname]], c(
        "Stage 0" = "Stage0",
        "Stage 0a" = "Stage0",
        "Stage 0is" = "Stage0",
        "Stage I" = "Stage1",
        "Stage IA" = "Stage1",
        "Stage IA1" = "Stage1",
        "Stage IA2" = "Stage1",
        "Stage IA3" = "Stage1",
        "Stage IB" = "Stage1",
        "Stage IB1" = "Stage1",
        "Stage IB2" = "Stage1",
        "Stage IC" = "Stage1",
        "Stage II" = "Stage2",
        "Stage IIA" = "Stage2",
        "Stage IIA1" = "Stage2",
        "Stage IIA2" = "Stage2",
        "Stage IIB" = "Stage2",
        "Stage IIC" = "Stage2",
        "Stage IIC1" = "Stage2",
        "Stage III" = "Stage3+",
        "Stage IIIA" = "Stage3+",
        "Stage IIIB" = "Stage3+",
        "Stage IIIC" = "Stage3+",
        "Stage IIIC1" = "Stage3+",
        "Stage IIIC2" = "Stage3+",
        "Stage IS" = "Stage1",
        "Stage IV" = "Stage1",
        "Stage IVA" = "Stage1",
        "Stage IVB" = "Stage1",
        "Stage IVC" = "Stage1",
        "Stage Tis" = "Stage0", # Small mutated cells - some do not consider this as cancer
        "Stage X" = "Stage X",
        "Unknown" = NA,
        "Not Reported" = NA),
        warn_missing = FALSE
      )
    }
    if (colname == "ajcc_pathologic_t") {
      model.data[[name]]$clinical[[colname]] <- revalue(model.data[[name]]$clinical[[colname]], c(
        "T0" = "T0",
        "T1" = "T1",
        "T1a" = "T1",
        "T1a1" = "T1",
        "T1a2" = "T1",
        "T1b" = "T1",
        "T1b1" = "T1",
        "T1b2" = "T1",
        "T1c" = "T1",
        "T1mi" = "T1",
        "T2" = "T2",
        "T2a" = "T2",
        "T2a1" = "T2",
        "T2a2" = "T2",
        "T2b" = "T2",
        "T2c" = "T2",
        "T2d" = "T2",
        "T3" = "T3+",
        "T3a" = "T3+",
        "T3b" = "T3+",
        "T3c" = "T3+",
        "T3d" = "T3+",
        "T4" = "T3+",
        "T4a" = "T3+",
        "T4b" = "T3+",
        "T4c" = "T3+",
        "T4d" = "T3+",
        "T4e" = "T3+",
        "TX" = "TX",
        "Ta" = "T1",
        "Tis" = "T0",
        "Tis (DCIS)" = "T0",
        "Tis (LCIS)" = "T0",
        "Tis (Paget's)" = "T0",
        "Unknown" = NA,
        "Not Reported" = NA),
        warn_missing = FALSE
      )
    }
    if (colname == "gender") {
      model.data[[name]]$clinical[[colname]] <- revalue(model.data[[name]]$clinical[[colname]], c(
        "female" = "female",
        "male" = "male",
        "unknown" = NA,
        "unspecified" = NA,
        "not reported" = NA),
        warn_missing = FALSE
      )
    }
    if (colname == "vital_status") {
      model.data[[name]]$clinical[[colname]] <- revalue(model.data[[name]]$clinical[[colname]], c(
        "Alive" = "Alive",
        "Dead" = "Dead",
        "Unknown" = NA,
        "Not Reported" = NA),
        warn_missing = FALSE
      )
    }
    if (colname == "prior_malignancy") {
      model.data[[name]]$clinical[[colname]] <- revalue(model.data[[name]]$clinical[[colname]], c(
        "yes" = "yes",
        "no" = "no",
        "unknown" = NA,
        "not reported" = NA,
        "Not Allowed To Collect" = NA),
        warn_missing = FALSE
      )
    }
    if (colname == "alcohol_history") {
      model.data[[name]]$clinical[[colname]] <- revalue(model.data[[name]]$clinical[[colname]], c(
        "Yes" = "Yes",
        "No" = "No",
        "Unknown" = NA,
        "Not Reported" = NA),
        warn_missing = FALSE
      )
    }
    if (colname == "ann_arbor_b_symptoms") {
      model.data[[name]]$clinical[[colname]] <- revalue(model.data[[name]]$clinical[[colname]], c(
        "yes" = "yes",
        "no" = "no",
        "unknown" = NA,
        "not reported" = NA),
        warn_missing = FALSE
      )
    }
    if (colname == "figo_stage") {
      model.data[[name]]$clinical[[colname]] <- revalue(model.data[[name]]$clinical[[colname]], c(
        "Stage 0" = "Stage0",
        "Stage I" = "Stage1",
        "Stage IA" = "Stage1",
        "Stage IA1" = "Stage1",
        "Stage IA2" = "Stage1",
        "Stage IB" = "Stage1",
        "Stage IB1" = "Stage1",
        "Stage IB2" = "Stage1",
        "Stage IC" = "Stage1",
        "Stage IC1" = "Stage1",
        "Stage IC2" = "Stage1",
        "Stage IC3" = "Stage1",
        "Stage II" = "Stage2",
        "Stage IIA" = "Stage2",
        "Stage IIA1" = "Stage2",
        "Stage IIA2" = "Stage2",
        "Stage IIB" = "Stage2",
        "Stage IIC" = "Stage2",
        "Stage III" = "Stage3+",
        "Stage IIIA" = "Stage3+",
        "Stage IIIA1" = "Stage3+",
        "Stage IIIA2" = "Stage3+",
        "Stage IIIAi" = "Stage3+",
        "Stage IIIAii" = "Stage3+",
        "Stage IIIB" = "Stage3+",
        "Stage IIIC" = "Stage3+",
        "Stage IIIC1" = "Stage3+",
        "Stage IIIC2" = "Stage3+",
        "Stage IV" = "Stage3+",
        "Stage IVA" = "Stage3+",
        "Stage IVB" = "Stage3+",
        "Unknown" = NA,
        "Not Reported" = NA),
        warn_missing = FALSE
      )
    }
    if (colname == "masaoka_stage") {
      model.data[[name]]$clinical[[colname]] <- revalue(model.data[[name]]$clinical[[colname]], c(
        "Stage I" = "Stage1",
        "Stage IIa" = "Stage2",
        "Stage IIb" = "Stage2",
        "Stage III" = "Stage3+",
        "Stage IVa" = "Stage3+",
        "Stage IVb" = "Stage3+"),
        warn_missing = FALSE
      )
    }
    # primary and secondary gleason grade are weird...
    # I am not sure how to rename their values, but since it only applies to a single tumor,
    # I just disregard it for now.
  }
}

```

### Clinical Variable availability

There are several missing data points in the clinical variables. The models need complete cases, so the variables that are missing in many of the cases need to be removed.

First I want to look at the availabilities for the clinical data, that is, the percentage of data points that are non-missing in each of the clinical data variables:

```{r}
get_availability <- function(clinical.data, cutoff, cut_0_mut = FALSE){
  #' Produce a dataframe containing the relative percentage availability of clinical data
  #'
  #' @param x Data as created by project.py clinical frequency function
  #' @param cutoff Remove all fields with % less than this value.
  #' @param cut_0_mut If true, removes patients with 0 driver mutations before computing the availabilities.
  #' @return Data frame, with one row for each variable containing the fractional availability
  #'
  #' The dataframe's rows are named as the variables that they represent.

  if(cut_0_mut){
    clinical.data <- subset(clinical.data, clinical.data$frequency != 0)
  }
  # Numbers holds the amount of non-na values in the dataframe
  numbers <- colSums(!is.na(clinical.data))
  numbers <- numbers/length(clinical.data[,1])*100
  numbers <- subset(numbers, numbers >= cutoff)
  frame <- data.frame(numbers)
  colnames(frame) <- "fractional.availability"
  return(frame)
}

for (name in p.names) {
  get_availability(model.data[[name]]$clinical, cutoff=0) -> model.data[[name]]$availability
  # I need the frame to be named as the tumor type, for a later calculation (see next block)
  colnames(model.data[[name]]$availability) <- name
}
```

To visualize them better, I'll make them in a single dataframe.

```{r, include=FALSE}
availabilities <- list()
for (name in p.names) {
  availabilities[[name]] <- rownames_to_column(model.data[[name]]$availability, var="ID")
}
fused.avail <- reduce(availabilities, merge, by = "ID", all = TRUE)
# The dataframe is actually massive. We have looked at it in excel in the meeting of the
# 8th of March 2021, so I won't include it here.
fused.avail
```

To show only those variables available for each tumor type, I filter the above frame to keep only those variables that are available (>90%) in all tumours.

### Clinical/Pathologic overlap

We prefer the ajcc codes from clinical evaluation (examined by a medical practitioner). But if they are not available, we use the pathologic values (from a simple examination).

I think they are mutually exclusive. Let's check that:

```{r}
extract.avail <- function(project, percent) {
  #' Extract the clinical variables that are at least PERCENT available from PROJECT
  return(rownames(subset(project$availability, project$availability >= percent)))
}

mutual.exclusive.ajcc <- function(project, name) {
  # This is terrible, but I just don't want to do it manually
  data.vars <- extract.avail(project, 90)
  collided <- FALSE
  if ("ajcc_clinical_m" %in% data.vars & "ajcc_pathologic_m" %in% data.vars) {
    print(paste("In project", name, "ajcc m collides."))
    collided <- TRUE
  }
  if ("ajcc_clinical_n" %in% data.vars & "ajcc_pathologic_n" %in% data.vars) {
    print(paste("In project", name, "ajcc n collides."))
    collided <- TRUE
  }
  if ("ajcc_clinical_t" %in% data.vars & "ajcc_pathologic_t" %in% data.vars) {
    print(paste("In project", name, "ajcc t collides."))
    collided <- TRUE
  }
  if ("ajcc_clinical_stage" %in% data.vars & "ajcc_pathologic_stage" %in% data.vars) {
    print(paste("In project", name, "ajcc stage collides."))
    collided <- TRUE
  }
  if (!collided) {
    print(paste("No collisions detected for", name))
  }
}

for (name in p.names) {
  mutual.exclusive.ajcc(model.data[[name]], name)
}
```

There are some collisions. I take them into consideration when doing the models. See the relevant section below.

### Binary mutation Presence

Martina made some models where the driver frequency is modelled by the presence or absence of some driver mutations. I have some concerns about this: aren't the variables that we want to model the same thing as the variable that describes them? In any case, I need to reshape the data to have this kind of variable. I call such data `gene_labels`.

Martina mixed gene level and mutation level in her models, but I want to keep them separate. I'd need some reshaping to make the patients have a string of binary values to use as labels.

```{r}
reshape_crystal <- function(project){
  #' Reshape a project to a gene label data frame
  #'
  #' Moves from a project to a large data frame containing the presence or absence
  #' status of mutations encoded into 0 for not present and 1 for present.
  #' Each row is a different
  relevant <- project$crystal[,c("ID", "Renamed.HUGO", "Hugo")]
  # I stole this from stack overflow
  gene_labels <- relevant %>%
    pivot_longer(ends_with("hugo"), names_to = "genes") %>%
    complete(ID, value) %>%
    dplyr::mutate(genes = as.numeric(!is.na(genes))) %>%
    pivot_wider(names_from = value, values_from = genes, values_fn = max)
  # Putting `all.x=TRUE, all.y=TRUE` makes some NAs appear, which is weird....
  # TODO: Check if the length of the gene labels matrix is the same as the crystal,
  # but nothing should have been lost by the trasposition
  temp <- data.frame(ID = project$clinical[,c("ID")])
  gene_labels <- merge(gene_labels, temp, by = "ID", all = TRUE)
  # See disclaimer above. I think that the NAs come from 0-driver patients, that have no ID in the
  # pivoted gene_labels table, so the real labels should be zero
  gene_labels[is.na(gene_labels)] <- 0
  gene_labels <- merge(gene_labels, project$clinical[, c("ID", "passenger.freq", "driver.freq")], by = "ID")
  # These are very long vectors but with just two levels. I could cast them to factors but some
  # functions later on fail.
  return(gene_labels)
}

for (name in p.names) {
  model.data[[name]]$gene_labels <- reshape_crystal(model.data[[name]])
}
```

Now we have available as variables the presence or absence of each mutations present in the crystal. This could be useful later on.

## Driver-Passenger frequency correlation

> Are the number of passenger and drivers correlated with eachother?

## Driver-Passenger Clinical modelling

> Are the number of drivers and passenger for each patient modelled well by the clinical variables?

### Description of used Clinical variables

We have at our disposal the variables collected by the TCGA consortium during the sampling process. They are source directly from the GDC data portal, and associated with their respective patients.

The clinical variables are detailed below. Source for this data is the GDC data dictionary. I use the Demographic, Diagnosis and Exposures clinical data. There are other types of data in the portal (Family History, Follow ups and more), but they are one-to-many (for instance, one patient might have more than one family member with cancer, or more than one follow up), so they have to be aggregated in some way. Since this is non-trivial, I ignored them (at least for now).

The main variables are described here. The actual detection of which variables are available is further down this report, in the "Model Data preprocessing" section.

Ignoring the data columns `driver.freq`, `passenger.freq` and `ID`, we have a total number of 39 clinical variables that are available in at least one tumor type. These are:

* **Demographic**
  * `age_at_index` : (int) The patient's age (in years) on the reference or anchor date date used during date obfuscation.
  * `days_to_birth` : (int) Number of days between the date used for index and the date from a person's date of birth represented as a calculated negative number of days.
  * `ethnicity` : (Enum) [__required__] An individual's self-described social and cultural grouping, specifically whether an individual describes themselves as Hispanic or Latino. The provided values are based on the categories defined by the U.S. Office of Management and Business and used by the U.S. Census Bureau.
  * `gender` : (Enum) [__required__] Text designations that identify gender. Gender is described as the assemblage of properties that distinguish people on the basis of their societal roles. Self-reported.
  * `race` : (Enum) [__required__] An arbitrary classification of a taxonomic group that is a division of a species. It usually arises as a consequence of geographical isolation within a species and is characterized by shared heredity, physical attributes and behavior, and in the case of humans, by common history, nationality, or geographic distribution. The provided values are based on the categories defined by the U.S. Office of Management and Business and used by the U.S. Census Bureau.
  * `vital_status` : (Enum) [__required__] The survival state of the person registered on the protocol.
  * `year_of_birth` : (int) Numeric value to represent the calendar year in which an individual was born.
* **Diagnosis**:
  * `age_at_diagnosis` : (int) [__required__] Age at the time of diagnosis expressed in number of days since birth.
  * `ajcc_clinical_m` : (Enum) Extent of the distant metastasis for the cancer based on evidence obtained from clinical assessment parameters determined prior to treatment.
    * MX: Cannot be measured
    * M0: Cancer has not spread to other parts of the body
    * cM0 (i+): Minimal cancer spread (less than 0.2mm areas of cancer spread)
    * M1/M1a/M1b/M1c: Cancer has spread to other parts of the body
  * `ajcc_clinical_n` : (Enum) Extent of the regional lymph node involvement for the cancer based on evidence obtained from clinical assessment parameters determined prior to treatment.
    * NX: Cannot be measured
    * N0: There is no cancer in nearby lymph nodes
    * N1-4: Number and location of lymph nodes that show the presence of cancer cells. Several variations exist, such as N0 (1+/-), N11/b/c, etc...
  * `ajcc_clinical_stage` : (Enum) Stage group determined from clinical information on the tumor (T), regional node (N) and metastases (M) and by grouping cases with similar prognosis for cancer. Stage I to IV, with several possible modifiers
  * `ajcc_clinical_t` : (Enum) Extent of the primary cancer based on evidence obtained from clinical assessment parameters determined prior to treatment.
    * TX: Cannot be measured
    * T0: Cannot be found
    * T1-4: Larger stages mean large cell mass and/or penetration into tissues
  * `ajcc_pathologic_m` : (Enum) Code to represent the defined absence or presence of distant spread or metastases (M) to locations via vascular channels or lymphatics beyond the regional lymph nodes, using criteria established by the American Joint Committee on Cancer (AJCC). Same levels as `ajcc_clinical_m`.
  * `ajcc_pathologic_n` : (Enum) The codes that represent the stage of cancer based on the nodes present (N stage) according to criteria based on multiple editions of the AJCC's Cancer Staging Manual. Same levels as `ajcc_clinical_n`.
  * `ajcc_pathologic_stage` : (Enum) The extent of a cancer, especially whether the disease has spread from the original site to other parts of the body based on AJCC staging criteria. Same levels as `ajcc_clinical_stage`.
  * `ajcc_pathologic_t` : () Code of pathological T (primary tumor) to define the size or contiguous extension of the primary tumor (T), using staging criteria from the American Joint Committee on Cancer (AJCC). Same levels as `ajcc_clinical_t`.
  * `ajcc_staging_system_edition` : (Enum) The text term used to describe the version or edition of the American Joint Committee on Cancer Staging Handbooks, a publication by the group formed for the purpose of developing a system of staging for cancer that is acceptable to the American medical profession and is compatible with other accepted classifications. There are 8 possible editions, from 1st to 8th.
  * `ann_arbor_b_symptoms` : (Binary Enum) Text term to signify whether lymphoma B-symptoms are present as noted in the patient's medical record.
  * `ann_arbor_extranodal_involvement` : (Enum) The text term used to describe the clinical classification of lymphoma, as defined by the Ann Arbor Lymphoma Staging System.
  * `days_to_diagnosis`: (int) Number of days between the date used for index and the date the patient was diagnosed with the malignant disease.
  * `days_to_last_follow_up` : (int) Time interval from the date of last follow up to the date of initial pathologic diagnosis, represented as a calculated number of days.
  * `figo_stage` : (Enum) The extent of a cervical or endometrial cancer within the body, especially whether the disease has spread from the original site to other parts of the body, as described by the International Federation of Gynecology and Obstetrics (FIGO) stages.
  * `icd_10_code`: (str) Alphanumeric value used to describe the disease code from the tenth version of the International Classification of Disease (ICD-10).
  * `masaoka_stage` : (Enum) The text term used to describe the Masaoka staging system, a classification that defines prognostic indicators for thymic malignancies and predicts tumor recurrence.
  * `morphology` : (Enum) [__required__] The third edition of the International Classification of Diseases for Oncology, published in 2000 used principally in tumor and cancer registries for coding the site (topography) and the histology (morphology) of neoplasms. The study of the structure of the cells and their arrangement to constitute tissues and, finally, the association among these to form organs. In pathology, the microscopic process of identifying normal and abnormal morphologic characteristics in tissues, by employing various cytochemical and immunocytochemical stains. A system of numbered categories for representation of data.
  * `primary_diagnosis` : (Enum) [__required__] Text term used to describe the patient's histologic diagnosis, as described by the World Health Organization's (WHO) International Classification of Diseases for Oncology (ICD-O).
  * `primary_gleason_grade` : (Enum) The text term used to describe the primary Gleason score, which describes the pattern of cells making up the largest area of the tumor. The primary and secondary Gleason pattern grades are combined to determine the patient's Gleason grade group, which is used to determine the aggresiveness of prostate cancer. Note that this grade describes the entire prostatectomy specimen and is not specific to the sample used for sequencing.
  * `prior_malignancy` : (Enum)  The yes/no/unknown indicator used to describe the patient's history of prior cancer diagnosis.
  * `prior_treatment` : (Enum) A yes/no/unknown/not applicable indicator related to the administration of therapeutic agents received before the body specimen was collected.
  * `site_of_resection_or_biopsy` : (Enum) [__required__] The text term used to describe the anatomic site of origin, of the patient's malignant disease, as described by the World Health Organization's (WHO) International Classification of Diseases for Oncology (ICD-O).
  * `secondary_gleason_grade` : (Enum) The text term used to describe the secondary Gleason score, which describes the pattern of cells making up the second largest area of the tumor. The primary and secondary Gleason pattern grades are combined to determine the patient's Gleason grade group, which is used to determine the aggresiveness of prostate cancer. Note that this grade describes the entire prostatectomy specimen and is not specific to the sample used for sequencing.
  * `synchronous_malignancy` : (Binary Enum) A yes/no/unknown indicator used to describe whether the patient had an additional malignant diagnosis at the same time the tumor used for sequencing was diagnosed. If both tumors were sequenced, both tumors would have synchronous malignancies.
  * `tissue_or_organ_of_origin` : (Enum) [__required__] The text term used to describe the anatomic site of origin, of the patient's malignant disease, as described by the World Health Organization's (WHO) International Classification of Diseases for Oncology (ICD-O).
  * `year_of_diagnosis` : (int) Numeric value to represent the year of an individual's initial pathologic diagnosis of cancer.
* **Exposures**:
  * `alcohol_history` : (Binary Enum) A response to a question that asks whether the participant has consumed at least 12 drinks of any kind of alcoholic beverage in their lifetime.
* **Follow Up**:
  * `bmi` : (number) A calculated numerical quantity that represents an individual's weight to height ratio.
  * `height` : (number) The height of the patient in centimeters.
  * `weight` : (number) The weight of the patient measured in kilograms.

Note that I cannot find the `tumor_stage` variable in the GDC data portal, however it looks like, from cursory inspection, that it is identical to the `ajcc_pathologic_stage`. I'm not sure where it comes from... Maybe I made it and forgot? I doubt it.

I first define some helper functions that will be useful throughout the modelling process.

```{r}
extract.avail <- function(project, percent) {
  #' Extract the clinical variables that are at least PERCENT available from PROJECT
  return(rownames(subset(project$availability, project$availability >= percent)))
}

# This is just to print "no variables" if none are selected.
ornone <- function(x) {
  #' Return x if it is not empty, else return "No Variables"
  if (length(x) > 0) {
    return(x)
  } else {
    return("No Variables")
  }
}

best <- function(glmulti) {
  #' Extract the best model from a glmulti output
  return(glmulti@objects[[1]])
}

exclude <- function(dframe, rows) {
  #' Exclude ROWS from a dataframe.
  return(dframe[-rows, ])
}

make.formula <- function(response, predictors) {
  #' Helper to paste together a response and predictors to a formula-like string
  return(paste(response, paste(predictors, collapse = "+"), sep = " ~ "))
}
```

Now I make a function that automatically selects the variables of interest form the lists we defined earlier (see the `Variable Level simplification` section), and produces a model formula automatically. It also returns the model data without `NA`s, and some additonal parameters needed by the function that makes the actual models.

This is not at all elegant, but I just wanted something that worked.

```{r}
select.vars <- function(project, percent = 90) {
  #' Select the variables to use in the models
  #'
  #' Retains only variables that have more than one level (the others would cause the models
  #' to crash) and those available.
  #' Returns the cleaned model data together with the selected variables.
  #' Also includes the data numerosity.
  #'
  #' The variables selected are those defined by us beforehand.

  # 0 and 1 factor levels are useless. So I remove them here
  to.remove <- c()
  for (variable in names(project$clinical)) {
    if (is.factor(project$clinical[[variable]]) | is.character(project$clinical[[variable]])) {
      if (nlevels(as.factor(project$clinical[[variable]])) < 2) {
        to.remove <- c(to.remove, variable)
      }
    }
  }
  # Selects the variables to use in the model
  avail.vars <- extract.avail(project, percent)
  out <- "Available variables:\n"
  generic.vars.in <- avail.vars[avail.vars %in% selected.vars]
  generic.vars.in <- generic.vars.in[!generic.vars.in %in% to.remove]
  out <- paste(out, paste(generic.vars.in, collapse = " + "), "\n", sep="")
  out <- paste(out, "Tumor-Specific Variables:\n", sep = "")
  tspec.vars.in <- avail.vars[avail.vars %in% tumor.spec.vars]
  tspec.vars.in <- tspec.vars.in[!tspec.vars.in %in% to.remove]
  out <- paste(out, paste(ornone(tspec.vars.in), collapse = " + "), "\n", sep="")

  cat(out)
  completecases <- na.omit(project$clinical[, c(generic.vars.in, tspec.vars.in, "ID", "passenger.freq", "driver.freq")])
  numerosity <- length(completecases$ID)
  print(paste("Nr. vars:", length(c(generic.vars.in, tspec.vars.in)), "- Numerosity:", numerosity, "sqrt:", round(sqrt(numerosity), 2)))

  # Generate the model data
  return(list(
    # Cleaned data to be used in the model
    completecases,
    # All variables that will be tested
    c(generic.vars.in, tspec.vars.in),
    # Numerosities that are taken into account to select the nr. of variables to include in the model
    floor(numerosity / 10),
    floor(sqrt(numerosity))
    )
  )
}

```

The lib `ggfortify` has an `autoplot` function that can be used to quickly see the model quality at a glance. So I use it now to check for model quality. However, it's bad at showing points with high leverage. I had made a function some time ago that did the same, but printed the list of points with high leverage. I paste it here. It was initially used to test `glmer` models, by which `autoplot` does not apply.

```{r}
diagnose.glmer <- function(model, leverage.threshold = 0.175, name = "") {
  #' Function made to supplant `autoplot` from ggfortify for glmer models
  library(gridExtra)
  library(ggplot2)
  qqplot.data <- function (vec) {
    y <- quantile(vec[!is.na(vec)], c(0.25, 0.75))
    x <- qnorm(c(0.25, 0.75))
    slope <- diff(y) / diff(x)
    int <- y[1L] - slope * x[1L]

    d <- data.frame(resids = vec)
    plot <- ggplot(d, aes(sample = resids)) +
      stat_qq(alpha = 0.8) +
      geom_abline(
        slope = slope,
        intercept = int,
        col = "blue",
        alpha = 0.8
      ) +
      ggtitle("Normal Q-Q of Residuals") +
      theme_minimal() +
      xlab("Theoretical Quantiles") + ylab("Pearson Residuals")
    return(plot)
  }

  p1 <- ggplot(data.frame(
    eta = predict(model, type = "link"),
    pearson = residuals(model, type = "pearson")
  ),
  aes(x = eta, y = pearson)) +
    geom_point(alpha = 0.8) +
    theme_minimal() +
    ggtitle("Residuals vs Estimates") +
    xlab("Estimates") + ylab("Pearson Residuals") +
    geom_smooth(
      col = "blue",
      method = "loess",
      formula = "y ~ x",
      se = FALSE,
      alpha = 0.8,
      size = 0.7
    )

  p2 <- qqplot.data(residuals(model))

  lever <- suppressWarnings(hatvalues(model))
  toohigh <- which(lever >= leverage.threshold)
  len <- length(residuals(model))

  stuff <-
    data.frame(
      lev = lever,
      pearson = residuals(model, type = "pearson"),
      len = seq(from = 1, to = len, by = 1)
    )

  p3 <- ggplot(stuff, aes(x = lev, y = pearson, label = len)) +
    geom_point(alpha = 0.8) +
    theme_minimal() +
    ggtitle("Residuals vs Leverage") +
    xlab("Leverage") + ylab("Pearson Residuals") +
    geom_point(
      data = subset(stuff, stuff$lev >= leverage.threshold),
      col = "red",
      shape = 1,
      size = 2.8
    ) +
    geom_smooth(
      col = "blue",
      method = "loess",
      formula = "y ~ x",
      se = FALSE,
      alpha = 0.8,
      size = 0.7
    )

  objclass <- suppressWarnings(class(model))[1]

  #if (objclass == "glmerMod") {
  if (TRUE) {
    p4 <-
      ggplot(model, aes(fitted(model), sqrt(abs(
        residuals(model)
      )))) + geom_point(na.rm = TRUE) +
      stat_smooth(
        method = "loess",
        na.rm = TRUE,
        col = "blue",
        size = 0.7,
        se = FALSE
      ) + xlab("Fitted Value") +
      ylab(expression(sqrt("|Standardized residuals|"))) +
      ggtitle("Scale-Location") + theme_minimal()
    if (name != "") {
      grid.arrange(p1, p2, p4, p3, nrow = 2, top = name)
    } else {
      grid.arrange(p1, p2, p4, p3, nrow = 2)
    }
  } else{
    if (name != "") {
      grid.arrange(p1, p2, p3, nrow = 2, top = name)
    } else {
      grid.arrange(p1, p2, p3, nrow = 2)
    }
  }


  if (length(toohigh) != 0) {
    print(
      paste(
        "The point(s)",
        paste(toohigh, collapse = ", "),
        "have leverage which is higher than",
        leverage.threshold,
        sep = " "
      )
    )
  }
}
```

I use `glmulti` to automate the model search process to get an overview of the models that can be produced. We'll discuss them together and see which are good to be used and refined later. I'll note down my thoughts on the PDF.

My thoughts on the decisions I took when making these preliminary models are in the comments in the function itself.

```{r}
make.models <- function(project, exclude.pts = NULL, level = 1, leverage.treshold = 0.175, avail.percent = 90, ignore.vars = NULL) {
  #' Generate preliminary models for a project
  #'
  #' @param exclude.pts A integer vector with the row numbers of observations that should be removed from the data before calculating the models.
  #' @param level An integer that describes the level of the glmulti analysis. Level 2 includes two-way interactions between variables, while 1 does not.
  #' @param leverage.treshold Passed onto `diagnose_glmer` as leverage treshold to warn about points with too high leverage.
  #' @param avail.percent Considers only variables that are at least this available (in percentile). Defaults to 90% available
  #' @param ignore.vars A character vectors of variables to exclude a priori from the analysis.
  #'
  #' Calculating level 2 models takes a long, long time.

  # Unpack the output from select.vars
  x <- select.vars(project, percent = avail.percent)
  # Unpacking the model data...
  if (!is.null(exclude.pts)) {
    model.data <- exclude(x[[1]], exclude.pts)
  } else {
    model.data <- x[[1]]
  }
  # The variables that need to be used ...
  vars <- x[[2]]
  if (!is.null(ignore.vars)) {
    if (any(vars %in% ignore.vars)) {
      print("Ignoring variables")
      vars <- vars[!vars %in% ignore.vars]
    } else {
      print("There are variables to ignore, but none of them are considered")
    }
  }
  # And the maximum number of variables. x[[3]] is nr.obs / 10, while x[[4]] is sqrt(nr.obs)
  # I take the smallest of the two, to be conservative for smaller n (/10 is smallest), and also for large
  # n (sqrt is smallest)
  max.vars <- min(x[[3]], x[[4]])

  models <- list()

  # A few words for all models: I set `report` and `plotty` to false to suppress the output of the
  # glmulti calculation. I also run an exhaustive search (method = "h"). Finally, I set the analysis
  # to respect the marginality principle, although this is ignored if level = 1.

  # Passenger models
  print("Generating Passenger Model - Gauss")
  # A glm model with gaussian family is a linear model
  models$all.pass.gauss <- glmulti(y = "passenger.freq", xr = vars, level = level, report = FALSE, plotty = FALSE, data=model.data, method = "h", family = gaussian, marginality = TRUE, maxsize = x[[3]])
  cat("Best passenger model - Gauss")
  best(models$all.pass.gauss) %>% summary() %>% print()
  best(models$all.pass.gauss) %>% diagnose.glmer(leverage.treshold, name = "Pass Gauss")
  best(models$all.pass.gauss) %>% autoplot() %>% print()

  # >>> Poisson is better suited for count data.
  print("Generating Passenger Model - Poisson")
  models$all.pass.poiss <- glmulti(y = "passenger.freq", xr = vars, level = level, report = FALSE, plotty = FALSE, data=model.data, method = "h", family = poisson, marginality = TRUE, maxsize = x[[3]])
  print("Best passenger model - Poisson")
  best(models$all.pass.poiss) %>% summary() %>% print()
  best(models$all.pass.poiss) %>% diagnose.glmer(leverage.treshold, name = "Pass Poiss")
  best(models$all.pass.poiss) %>% autoplot() %>% print()

  # I tried a quasipoisson model but it gives a weird `cricri` error, and I think it's inside
  # the implementation for glmulti, from the source code. I don't know how to fix it, really.
  # So I'll just make a single model with all variables from the poisson model.

  print("Making quasipoisson passenger model.")
  models$simple.pass.qpoiss <- glm(formula(best(models$all.pass.poiss)), data = model.data, family = quasipoisson)
  print("Best passenger model - Quasi Poisson")
  models$simple.pass.qpoiss %>% summary() %>% print()
  models$simple.pass.qpoiss %>% diagnose.glmer(leverage.treshold, name = "Pass Qpoiss")
  models$simple.pass.qpoiss %>% autoplot() %>% print()

  print("Generating passenger model - Negative Binomial")
  # The Poisson models seem overdispersed. In this case it's advisable to try a negative
  # binomial distribution, which handles overdispersed data.
  models$all.pass.nb <- glmulti(y = "passenger.freq", xr = vars, level = level, report = FALSE, plotty = FALSE, data=model.data, method = "h", fitfunction = glm.nb, marginality = TRUE, maxsize = x[[3]])
  print("Best passenger model - Negative Binomial")
  best(models$all.pass.nb) %>% summary() %>% print()
  best(models$all.pass.nb) %>% diagnose.glmer(leverage.treshold, name = "Pass NegBi")

  # >>> Driver models
  print("generating Driver Model - Gauss")
  # Again, first a simple linear model.
  models$all.driver.gauss <- glmulti(y = "driver.freq", xr = vars, level = level, report = FALSE, plotty = FALSE, data=model.data, method = "h", family = gaussian, marginality = TRUE, maxsize = x[[3]])
  print("Best Driver model - Gauss")
  best(models$all.driver.gauss) %>% summary() %>% print()
  best(models$all.driver.gauss) %>% diagnose.glmer(leverage.treshold, name = "Driver Gauss")
  best(models$all.driver.gauss) %>% autoplot() %>% print()

  # cannot do a driver model for Poisson or QuasiPoisson as there are zeroes and the loglink
  # cannot handle them.

  print("generating Driver Model - Negative Binomial")
  models$all.driver.gauss <- glmulti(y = "driver.freq", xr = vars, level = level, report = FALSE, plotty = FALSE, data=model.data, method = "h", fitfunction = glm.nb, marginality = TRUE, maxsize = x[[3]])
  print("Best Driver model - Negative Binomial")
  best(models$all.driver.gauss) %>% summary() %>% print()
  best(models$all.driver.gauss) %>% diagnose.glmer(leverage.treshold, name = "Driver NegBi")
  best(models$all.driver.gauss) %>% autoplot() %>% print()

  return(models)
}
```

Driver modelling is difficult as the models are zero-inflated. So I'm thinking of hurdle models, or distributions that handle zero-inflation. However I do not know how to use them.

I now run the analysis on all tumor types and observe the output.

```{r}
# Just a holder for the objects. TODO: do not remake the models that are already created.
models <- list()
```

### TCGA-ACC

```{r}
models$`TCGA-ACC` <- make.models(model.data$`TCGA-ACC`, leverage.treshold = 0.5)
```

### TCGA-BLCA

```{r}
models$`TCGA-BLCA` <- make.models(model.data$`TCGA-BLCA`, leverage.treshold = 0.5)
```
### TCGA-BRCA

```{r}
models$`TCGA-BRCA` <- make.models(model.data$`TCGA-BRCA`, leverage.treshold = 0.5)
```

### TCGA-CESC

```{r}
models$`TCGA-CESC` <- make.models(model.data$`TCGA-CESC`, leverage.treshold = 0.5)
```

### TCGA-CHOL

```{r}
models$`TCGA-CHOL` <- make.models(model.data$`TCGA-CHOL`, leverage.treshold = 0.5)
```

### TCGA-COAD

```{r}
models$`TCGA-COAD` <- make.models(model.data$`TCGA-COAD`, leverage.treshold = 0.5)
```

### TCGA-DLBC

```{r}
models$`TCGA-DLBC` <- make.models(model.data$`TCGA-DLBC`, leverage.treshold = 0.5)
```

### TCGA-ESCA

```{r}
models$`TCGA-ESCA` <- make.models(model.data$`TCGA-ESCA`, leverage.treshold = 0.5)
```

### TCGA-GBM

```{r}
models$`TCGA-GBM` <- make.models(model.data$`TCGA-GBM`, leverage.treshold = 0.5)
```

### TCGA-HNSC

```{r}
models$`TCGA-HNSC` <- make.models(model.data$`TCGA-HNSC`, leverage.treshold = 0.5, ignore.vars = c("ajcc_pathologic_n", "ajcc_pathologic_t"))
```

### TCGA-KICH

```{r}
models$`TCGA-KICH` <- make.models(model.data$`TCGA-KICH`, leverage.treshold = 0.5)
```

### TCGA-KIRC

```{r}
models$`TCGA-KIRC` <- make.models(model.data$`TCGA-KIRC`, leverage.treshold = 0.5)
```

### TCGA-KIRP

```{r}
models$`TCGA-KIRP` <- make.models(model.data$`TCGA-KIRP`, leverage.treshold = 0.5, ignore.vars = c("ajcc_pathologic_m"))
```

### TCGA-LAML

```{r}
models$`TCGA-LAML` <- make.models(model.data$`TCGA-LAML`, leverage.treshold = 0.5)
```

### TCGA-LGG

```{r}
models$`TCGA-LGG` <- make.models(model.data$`TCGA-LGG`, leverage.treshold = 0.5)
```

### TCGA-LIHC

```{r}
models$`TCGA-LIHC` <- make.models(model.data$`TCGA-LIHC`, leverage.treshold = 0.5)
```

### TCGA-LUAD

```{r}
models$`TCGA-LUAD` <- make.models(model.data$`TCGA-LUAD`, leverage.treshold = 0.5)
```

### TCGA-LUSC

This models fails at the driver for negative binomial, so I'm using a reduced function from above.

```{r}
make.models.no.dnb <- function(project, exclude.pts = NULL, level = 1, leverage.treshold = 0.175, avail.percent = 90, ignore.vars = NULL) {
  #' Generate preliminary models for a project
  #'
  #' @param exclude.pts A integer vector with the row numbers of observations that should be removed from the data before calculating the models.
  #' @param level An integer that describes the level of the glmulti analysis. Level 2 includes two-way interactions between variables, while 1 does not.
  #' @param leverage.treshold Passed onto `diagnose_glmer` as leverage treshold to warn about points with too high leverage.
  #' @param avail.percent Considers only variables that are at least this available (in percentile). Defaults to 90% available
  #' @param ignore.vars A character vectors of variables to exclude a priori from the analysis.
  #'
  #' Calculating level 2 models takes a long, long time.

  # Unpack the output from select.vars
  x <- select.vars(project, percent = avail.percent)
  # Unpacking the model data...
  if (!is.null(exclude.pts)) {
    model.data <- exclude(x[[1]], exclude.pts)
  } else {
    model.data <- x[[1]]
  }
  # The variables that need to be used ...
  vars <- x[[2]]
  if (!is.null(ignore.vars)) {
    if (any(vars %in% ignore.vars)) {
      print("Ignoring variables")
      vars <- vars[!vars %in% ignore.vars]
    } else {
      print("There are variables to ignore, but none of them are considered")
    }
  }
  # And the maximum number of variables. x[[3]] is nr.obs / 10, while x[[4]] is sqrt(nr.obs)
  # I take the smallest of the two, to be conservative for smaller n (/10 is smallest), and also for large
  # n (sqrt is smallest)
  max.vars <- min(x[[3]], x[[4]])

  models <- list()

  # A few words for all models: I set `report` and `plotty` to false to suppress the output of the
  # glmulti calculation. I also run an exhaustive search (method = "h"). Finally, I set the analysis
  # to respect the marginality principle, although this is ignored if level = 1.

  # Passenger models
  print("Generating Passenger Model - Gauss")
  # A glm model with gaussian family is a linear model
  models$all.pass.gauss <- glmulti(y = "passenger.freq", xr = vars, level = level, report = FALSE, plotty = FALSE, data=model.data, method = "h", family = gaussian, marginality = TRUE, maxsize = x[[3]])
  cat("Best passenger model - Gauss")
  best(models$all.pass.gauss) %>% summary() %>% print()
  best(models$all.pass.gauss) %>% diagnose.glmer(leverage.treshold, name = "Pass Gauss")
  best(models$all.pass.gauss) %>% autoplot() %>% print()

  # >>> Poisson is better suited for count data.
  print("Generating Passenger Model - Poisson")
  models$all.pass.poiss <- glmulti(y = "passenger.freq", xr = vars, level = level, report = FALSE, plotty = FALSE, data=model.data, method = "h", family = poisson, marginality = TRUE, maxsize = x[[3]])
  print("Best passenger model - Poisson")
  best(models$all.pass.poiss) %>% summary() %>% print()
  best(models$all.pass.poiss) %>% diagnose.glmer(leverage.treshold, name = "Pass Poiss")
  best(models$all.pass.poiss) %>% autoplot() %>% print()

  # I tried a quasipoisson model but it gives a weird `cricri` error, and I think it's inside
  # the implementation for glmulti, from the source code. I don't know how to fix it, really.
  # So I'll just make a single model with all variables from the poisson model.

  print("Making quasipoisson passenger model.")
  models$simple.pass.qpoiss <- glm(formula(best(models$all.pass.poiss)), data = model.data, family = quasipoisson)
  print("Best passenger model - Quasi Poisson")
  models$simple.pass.qpoiss %>% summary() %>% print()
  models$simple.pass.qpoiss %>% diagnose.glmer(leverage.treshold, name = "Pass Qpoiss")
  models$simple.pass.qpoiss %>% autoplot() %>% print()

  print("Generating passenger model - Negative Binomial")
  # The Poisson models seem overdispersed. In this case it's advisable to try a negative
  # binomial distribution, which handles overdispersed data.
  models$all.pass.nb <- glmulti(y = "passenger.freq", xr = vars, level = level, report = FALSE, plotty = FALSE, data=model.data, method = "h", fitfunction = glm.nb, marginality = TRUE, maxsize = x[[3]])
  print("Best passenger model - Negative Binomial")
  best(models$all.pass.nb) %>% summary() %>% print()
  best(models$all.pass.nb) %>% diagnose.glmer(leverage.treshold, name = "Pass NegBi")

  # >>> Driver models
  print("generating Driver Model - Gauss")
  # Again, first a simple linear model.
  models$all.driver.gauss <- glmulti(y = "driver.freq", xr = vars, level = level, report = FALSE, plotty = FALSE, data=model.data, method = "h", family = gaussian, marginality = TRUE, maxsize = x[[3]])
  print("Best Driver model - Gauss")
  best(models$all.driver.gauss) %>% summary() %>% print()
  best(models$all.driver.gauss) %>% diagnose.glmer(leverage.treshold, name = "Driver Gauss")
  best(models$all.driver.gauss) %>% autoplot() %>% print()

  return(models)
}
models$`TCGA-LUSC` <- make.models.no.dnb(model.data$`TCGA-LUSC`, leverage.treshold = 0.5)
```

### TCGA-MESO

```{r}
models$`TCGA-MESO` <- make.models(model.data$`TCGA-MESO`, leverage.treshold = 0.5)
```

### TCGA-OV

```{r}
models$`TCGA-OV` <- make.models(model.data$`TCGA-OV`, leverage.treshold = 0.5)
```

### TCGA-PAAD

```{r}
models$`TCGA-PAAD` <- make.models(model.data$`TCGA-PAAD`, leverage.treshold = 0.5)
```

### TCGA-PCPG

```{r}
models$`TCGA-PCPG` <- make.models(model.data$`TCGA-PCPG`, leverage.treshold = 0.5)
```

### TCGA-PRAD

This tumor has something weird. The NAs overlap so well that the dataframe ends up empty if I don't set the filtering to at least 99 percent.

```{r}
#models$`TCGA-PRAD` <- make.models(model.data$`TCGA-PRAD`, leverage.treshold = 0.5, avail.percent = 100)
```

### TCGA-READ

```{r}
models$`TCGA-READ` <- make.models(model.data$`TCGA-READ`, leverage.treshold = 0.5)
```

### TCGA-SARC

```{r}
models$`TCGA-SARC` <- make.models(model.data$`TCGA-SARC`, leverage.treshold = 0.5)
```

### TCGA-SKCM

```{r}
models$`TCGA-SKCM` <- make.models(model.data$`TCGA-SKCM`, leverage.treshold = 0.5)
```

### TCGA-STAD

```{r}
models$`TCGA-STAD` <- make.models(model.data$`TCGA-STAD`, leverage.treshold = 0.5)
```

### TCGA-TGCT

```{r}
models$`TCGA-TGCT` <- make.models(model.data$`TCGA-TGCT`, leverage.treshold = 0.5, avail.percent = 85)
```

### TCGA-THCA

```{r}
models$`TCGA-THCA` <- make.models(model.data$`TCGA-THCA`, leverage.treshold = 0.5)
```

### TCGA-THYM

```{r}
models$`TCGA-THYM` <- make.models(model.data$`TCGA-THYM`, leverage.treshold = 0.5)
```

### TCGA-UCEC

```{r}
models$`TCGA-UCEC` <- make.models(model.data$`TCGA-UCEC`, leverage.treshold = 0.5)
```

### TCGA-UCS

```{r}
models$`TCGA-UCS` <- make.models(model.data$`TCGA-UCS`, leverage.treshold = 0.5)
```

### TCGA-UVM

```{r}
models$`TCGA-UVM` <- make.models(model.data$`TCGA-UVM`, leverage.treshold = 0.5, ignore.vars = c("ajcc_pathologic_m", "ajcc_pathologic_t", "ajcc_pathologic_n", "ajcc_pathologic_stage"))
```

## Driver vs Passenger Models

> Are passenger and driver values correlated? Can we model the driver frequency based on the passengers?

I approach this like the other models, by making a function that tests out one or two `glm`s and plots the output.

```{r, fig.width=6, fig.height=4}
plot.driver.vs.pass <- function (clinical, name = "") {
  # I won't even try a linear relationship as the data is not linear. I'll try a poisson
  # and a negative binomial glm

  # The drivers and passengers are on a very different scale. But I cannot scale count data.
  # Some other form of model, maybe?
  clinical %>% dplyr::select(c(driver.freq, passenger.freq)) -> relevant

  models <- list()
  print(paste("Fitting models for", name))
  models$poisson <- glm(driver.freq ~ passenger.freq, data = relevant, family = poisson)
  models$negativebin <- glm.nb(driver.freq ~ passenger.freq, data = relevant)

  models$poisson %>% summary() %>% print()
  #models$poisson %>% diagnose.glmer(name = "Poisson")
  models$negativebin %>% summary() %>% print()
  models$negativebin %>% diagnose.glmer(name = "Negative Binomial")

  models$poisson %>% jtools::effect_plot(pred = passenger.freq, interval = TRUE, plot.points = TRUE, jitter = 0.1, main.title = paste("poisson", name)) %>% print()
  models$negativebin %>% jtools::effect_plot(pred = passenger.freq, interval = TRUE, plot.points = TRUE, jitter = 0.1, main.title = paste("negative binomial", name)) %>% print()
}

for (name in p.names) {
  plot.driver.vs.pass(model.data[[name]]$clinical, name)
}
```

# Clustering

My question is if the data clusters based on the types of mutations present in the tumours. The first thing to consider is that if the mutation occurs in just a single patient, then it doesn't form a cluster. I set a threshold of being present in at least 10% of all patients to be considered, and 1 at minimum.

There is the need to have some method of cluster quality analysis, so we use the DB index.

```{r, fig.width=8, fig.height=4}
get.cluster.distances <- function(project){
  possible.levels <- project$gene_labels
  possible.levels <- possible.levels[!colnames(possible.levels) %in% c("ID", "driver.freq", "passenger.freq")]
  possible.levels <- possible.levels[colSums(possible.levels) > max(length(possible.levels[1]) / 10, 25)]
  possible.levels.name <- colnames(possible.levels)
  if (length(possible.levels.name) == 0) {
    return(NULL)
  }
  # This is needed as the function expects clusters with names 1, 2, 3... not 0, 1, 2...
  possible.levels <- possible.levels + 1
  data <- project$gene_labels[, c("passenger.freq", "driver.freq")]

  distances <- list()

  for (name in possible.levels.name) {
    distances[[name]] <- index.DB(data, possible.levels[[name]])$DB
  }
  vector.dist <- reduce(distances, c)
  names(vector.dist) <- names(distances)
  return(vector.dist)
}

plot_distance <- function(labels, variable, name, DB_value){
  # I set the seed here so the different plots can be compared as they
  # will have the same jitter displacement
  set.seed(72)

  ylimits <- c(-0.5, max(labels$driver.freq + 0.5))

  p <- ggplot(labels, aes(passenger.freq, driver.freq)) +
    geom_jitter(alpha=0.7, height=0.2, aes(colour = as.factor(.data[[variable]]))) +
    scale_color_manual(values = c("0" = "palegreen3", "1" = "deeppink3"), labels = c("No", "Yes")) +
    scale_x_log10() +
    ylim(ylimits) +
    ggtitle(paste("Clustering by mutation", variable, name, paste("DB:", DB_value), sep = " - ")) +
    xlab("Passenger Frequency") + ylab("Driver Frequency") +
    annotation_logticks(sides = "b") +
    labs(color = "Mutated?") +
    theme_bw() + theme(panel.grid.minor = element_blank(), legend.position = "left")

  # Need a new frame with just the driver levels, and the associated non-coloured and coloured sums.
  labels %>% dplyr::select(!c(passenger.freq, ID)) %>% melt(id.vars = c("driver.freq")) -> bdata
  var <- variable
  bdata %>% group_by(driver.freq, value) %>% subset(variable == var) %>% summarise(count = n()) -> box.data

  y.box <- ggplot(box.data, aes(fill = as.factor(value), x = driver.freq, y = count)) +
    scale_fill_manual(values = c("0" = "palegreen3", "1" = "deeppink3")) +
    geom_bar(position = "fill", stat = "identity", width = 0.8) +
    scale_y_continuous(breaks = c(0, 0.5, 1), labels = c("0", "0.5", "1")) +
    theme_minimal() +
    theme(legend.position = "none", axis.title.y = element_blank(), axis.text.y = element_blank()) +
    xlab(element_blank()) + ylab(element_blank()) +
    coord_flip()

  plot_grid(p, y.box, nrow = 1, align = "h", rel_widths = c(1, 0.2))
}

make_cluster_plots <- function(project, name="", max_plots = 5, crop_dist = 90) {
  dists <- get.cluster.distances(project)
  if (is.null(dists)) {
    stop(paste("No viable distances to plot for", name))
  }
  dists <- sort(dists, decreasing = FALSE)

  names(dists) %>% head(max_plots) -> to_plot
  for (level in to_plot) {
    print(plot_distance(project$gene_labels, level, name, signif(dists[level], 3)))
  }
}


for (name in p.names) {
  tryCatch(make_cluster_plots(model.data[[name]], name, 2), error = function(e) {print(e)})
}
```

```{r, fig.width=8, fig.height=4}
plot_distance2 <- function(labels, variable, name, DB_value){
  # I set the seed here so the different plots can be compared as they
  # will have the same jitter displacement
  set.seed(72)

  ylimits <- c(-0.5, max(labels$driver.freq + 0.5))

  p <- ggplot(labels, aes(passenger.freq, driver.freq)) +
    geom_jitter(alpha=0.7, height=0.2, aes(colour = as.factor(.data[[variable]]))) +
    scale_color_manual(values = c("0" = "palegreen3", "1" = "deeppink3"), labels = c("Yes", "No")) +
    scale_x_log10() +
    ylim(ylimits) +
    ggtitle(paste("Clustering by mutation", variable, name, paste("DB:", DB_value), sep = " - ")) +
    xlab("Passenger Frequency") + ylab("Driver Frequency") +
    annotation_logticks(sides = "b") +
    labs(color = "Mutated?") +
    theme_bw() + theme(panel.grid.minor = element_blank(), legend.position = "left")

  # Need a new frame with just the driver levels, and the associated non-coloured and coloured sums.
  labels %>% dplyr::select(!c(passenger.freq, ID)) %>% melt(id.vars = c("driver.freq")) -> bdata
  var <- variable
  bdata %>% group_by(driver.freq, value) %>% subset(variable == var) %>% summarise(count = n()) -> box.data

  updated.data <- box.data

  for (driver.freq in box.data$driver.freq) {

  }

  y.box <- ggplot(box.data, aes(fill = as.factor(value), x = driver.freq, y = count)) +
    scale_fill_manual(values = c("0" = "palegreen3", "1" = "deeppink3")) +
    geom_bar(position = "fill", stat = "identity", width = 0.8) +
    scale_y_continuous(breaks = c(0, 0.5, 1), labels = c("0", "0.5", "1")) +
    theme_minimal() +
    theme(legend.position = "none", axis.title.y = element_blank(), axis.text.y = element_blank()) +
    xlab(element_blank()) + ylab(element_blank()) +
    coord_flip()

  plot_grid(p, y.box, nrow = 1, align = "h", rel_widths = c(1, 0.2))
}

make_cluster_plots2 <- function(project, name="", max_plots = 5, crop_dist = 90) {
  dists <- get.cluster.distances(project)
  if (is.null(dists)) {
    stop(paste("No viable distances to plot for", name))
  }
  dists <- sort(dists, decreasing = FALSE)

  names(dists) %>% head(max_plots) -> to_plot
  for (level in to_plot) {
    print(plot_distance2(project$gene_labels, level, name, signif(dists[level], 3)))
  }
}


for (name in p.names) {
  tryCatch(make_cluster_plots2(projects[[name]], name, 2), error = function(e) {print(e)})
}
```
